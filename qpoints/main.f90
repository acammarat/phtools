!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
! qpoints. Copyright (C) Antonio Cammarata
! https://nano.cvut.cz/researchers/antonio-cammarata
! https://orcid.org/0000-0002-5691-0682
! 
! Extracts phonon eigenvectors and eigenvalues from
! the file qpoints.yaml generated by PHONOPY
! ( https://phonopy.github.io/phonopy )
!
! If used for production, you should cite
! Phys. Rev. B XX, XXXXX (XXXX)
! https://doi.org/10.1103/xxx
!
!    This file is part of qpoints.
!
!    qpoints is free software: you can redistribute it and/or modify
!    it under the terms of the GNU General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    (at your option) any later version.
!
!    qpoints is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
!    GNU General Public License for more details.
!
!    You should have received a copy of the GNU General Public License
!    along with phonchar.  If not, see <http://www.gnu.org/licenses/>.
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
! v 1.4
! - changed header of qmatrix.nd and freq.nd
! - added info on GM, H and S point and sets
! - the number of skip modes is user-defined
! - new variables from pindol:
!   ! number of "unique" q-points (i.e. Gamma + set H + set S)
!   npG ! 0 or 1, if Gamma is present or not
!   npH ! number of points in the set H
!   npS ! number of points in the set S 
!
! v 1.3
! - changed header of qmatrix.nd and freq.nd
! - introduced a warning if the q-set is not ordered as GM, H, S
!   for pindol use
!
! v 1.2 
! - renamed qmatrix.dat and freq.dat in qmatrix.nd and freq.nd
! - the freq.nd file contains the labels of the Gamma modes to be 
!   skipped, to be read by phind v 4.1
!
! v 1.1 eigenvectors and frequences are written in one unique file each.
!
! v 1.0
! 
! Antonio Cammarata
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Format of the input file
!
! char                  phonopy executable including command line options;
!                       it is necessary to specify the unit cell with 
!                       -c unit_cell_file
! char                  POSCAR file of the unit cell
! int int int           mesh used to generate the FORCE_CONSTANTS file
! int                   nskip number of modes to skip
! int int ... int int   (q,j) list of modes to skip
! int                   number of q-points
! double double double  reduced components of the first q-point
! ...
! double double double  reduced components of the last q-point
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

module var
  ! global parameters
  character(3), parameter :: version='1.4'
  character(7), parameter :: progname = 'QPOINTS'
  real(8), parameter :: pi2 = 2.d0 * acos(-1.d0)
  ! from input
  integer, save :: npoints, nskip
  integer, save, allocatable :: skipmod(:,:)
  real(8), save :: side_eq_RC(3,3)
  real(8), save, allocatable :: q(:,:)
end module var

module functions
contains
  
  function i2a(i) result(out)
    character(:), allocatable :: out
    integer, intent(in) :: i
    character(range(i)+2) :: x

    write(x,'(i0)') i

    out = trim(x)
    
  end function i2a

  function cross(a, b)
    real(8) :: cross(3)
    real(8), intent(in) :: a(3), b(3)
  
    cross(1) = a(2) * b(3) - a(3) * b(2)
    cross(2) = a(3) * b(1) - a(1) * b(3)
    cross(3) = a(1) * b(2) - a(2) * b(1)
  end function cross

end module functions

module String_mod

    use iso_fortran_env, only: IK => int32
    implicit none
    public

    type :: CharVec_type
        character(:)    , allocatable   :: record
    end type CharVec_type

    type :: String_type
        character(:)      , allocatable   :: value          !< The string value.
        type(CharVec_type), allocatable   :: Parts(:)       !< The string parts.
        integer(IK)                       :: nPart = 0_IK   !< The number of parts in the string.
    contains
        procedure, nopass :: split
    end type String_type

contains

    function split(string,delim,npart) result(Parts)

        implicit none
        character(len=*)    , intent(in)            :: string, delim

        integer(IK)         , intent(out), optional :: npart

        type(CharVec_type)  , allocatable           :: Parts(:)
        integer(IK)         , allocatable           :: PartEnd(:)
        integer(IK)         , allocatable           :: PartBegin(:)
        integer(IK)                                 :: dlmlenMinusOne
        integer(IK)                                 :: strlen, dlmlen, npartMax, ipart, ibeg, iend, i
        logical                                     :: npartIsPresent

        dlmlen = len(delim)
        strlen = len(string)
        npartIsPresent = present(npart)

        ! if dlm is empty, return the whole string split character by character

        if (dlmlen==0_IK) then
            allocate(Parts(strlen))
            do ipart = 1, strlen
                Parts(ipart)%record = string(ipart:ipart)
            end do
            if (npartIsPresent) npart = strlen
            return
        end if

        npartMax = 1_IK + strlen / dlmlen ! There can be at most strlen + 1 splits
        allocate(PartBegin(npartMax), PartEnd(npartMax)) ! This will contain the beginning and the ends of the splits.
        dlmlenMinusOne = dlmlen - 1_IK

        ibeg = 0_IK
        ipart = 1_IK
        PartBegin(ipart) = 1_IK
        loopParseString: do

            ibeg = ibeg + 1_IK
            iend = ibeg + dlmlenMinusOne

            if (strlen<iend) then ! the remaining part of the string is shorter than the delim
                PartEnd(ipart) = strlen
                exit loopParseString
            elseif ( string(ibeg:iend) == delim ) then
                PartEnd(ipart) = ibeg - 1_IK
                ipart = ipart + 1_IK
                PartBegin(ipart) = iend + 1_IK
                ibeg = iend
            end if

        end do loopParseString

        allocate(Parts(ipart))
        do i = 1, ipart
            Parts(i)%record = string(PartBegin(i):PartEnd(i))
        end do
        if (present(npart)) npart = ipart

        deallocate(PartBegin, PartEnd)

    end function split
    
end module String_mod




program qpoints

  call init

  call qextract

  call credits

  write(*,'(a)') ' Execution terminated.'
  write(*,*)

  stop
end program qpoints
