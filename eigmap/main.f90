!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
! eigmap. Copyright (C) Antonio Cammarata
! https://nano.cvut.cz/researchers/antonio-cammarata
! https://orcid.org/0000-0002-5691-0682
! 
! Program to calculate the map between different eigenvector
! via the scalar product
!
! If used for production, you should cite
! Phys. Rev. B XX, XXXXX (XXXX)
! https://doi.org/10.1103/xxx
! where the formulation is reported in section II "Eigenvector map based on
! atomic displacements" of the Supplemental Material.
!
!    This file is part of eigmap.
!
!    eigmap is free software: you can redistribute it and/or modify
!    it under the terms of the GNU General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    (at your option) any later version.
!
!    eigmap is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
!    GNU General Public License for more details.
!
!    You should have received a copy of the GNU General Public License
!    along with phonchar.  If not, see <http://www.gnu.org/licenses/>.
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
! v 2.2
! - fixed a bug in the definition of Euclidean and Hermitian angle
!
! v 2.1
! - added possibility to map atoms to improve the phonon mapping; mapping is 
!   specified as
!   X -> Y
!   where X is the label of the atom in the reference structure and Y is the atom
!   in the structure with phonons to be compared
!   The eigenvector components of the reference structure are rearranged in the
!   read_eigen subroutine according to the mapping
!
! v 2.0
!
! - eigenvector and eigenfrequencies files are read from qmatrix.nd and freq.nd
!   generated by qpoints 1.4
!
! Antonio Cammarata
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Format of the input file
!
! char                  reference eigenvector file
! char                  reference frequency file
! char                  eigenvector file to compare
! char                  frequency file to compare
! int                   number of atoms to remap
! int int               atom_label in ref. structure -> atom_label in comp. structure
! ... ...
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


module var
  ! global parameters
  character(3), parameter :: version='2.2'
  character(6), parameter :: progname = 'EIGMAP'
  real(8), parameter :: pi = acos(-1.d0)
  real(8), parameter :: rad_to_deg = 180.d0/pi
  ! from input files
  character(256) :: qmatndref, freqndref, qmatndcomp, freqndcomp
  integer, save :: atoms_ref
  integer, save, allocatable :: atmap(:)
  ! from qmatrix_* and freq_*
  integer, save :: npunique, nq
  real(8), save, allocatable :: freq_ref(:,:), freq_comp(:,:)
  complex(8), save, allocatable :: eig_ref(:,:,:), eig_comp(:,:,:)
end module var

module functions
contains
  
  function i2a(i) result(out)
    character(:), allocatable :: out
    integer, intent(in) :: i
    character(range(i)+2) :: x

    write(x,'(i0)') i

    out = trim(x)
    
  end function i2a

end module functions

module String_mod

    use iso_fortran_env, only: IK => int32
    implicit none
    public

    type :: CharVec_type
        character(:)    , allocatable   :: record
    end type CharVec_type

    type :: String_type
        character(:)      , allocatable   :: value          !< The string value.
        type(CharVec_type), allocatable   :: Parts(:)       !< The string parts.
        integer(IK)                       :: nPart = 0_IK   !< The number of parts in the string.
    contains
        procedure, nopass :: split
    end type String_type

contains

    function split(string,delim,npart) result(Parts)

        implicit none
        character(len=*)    , intent(in)            :: string, delim

        integer(IK)         , intent(out), optional :: npart

        type(CharVec_type)  , allocatable           :: Parts(:)
        integer(IK)         , allocatable           :: PartEnd(:)
        integer(IK)         , allocatable           :: PartBegin(:)
        integer(IK)                                 :: dlmlenMinusOne
        integer(IK)                                 :: strlen, dlmlen, npartMax, ipart, ibeg, iend, i
        logical                                     :: npartIsPresent

        dlmlen = len(delim)
        strlen = len(string)
        npartIsPresent = present(npart)

        ! if dlm is empty, return the whole string split character by character

        if (dlmlen==0_IK) then
            allocate(Parts(strlen))
            do ipart = 1, strlen
                Parts(ipart)%record = string(ipart:ipart)
            end do
            if (npartIsPresent) npart = strlen
            return
        end if

        npartMax = 1_IK + strlen / dlmlen ! There can be at most strlen + 1 splits
        allocate(PartBegin(npartMax), PartEnd(npartMax)) ! This will contain the beginning and the ends of the splits.
        dlmlenMinusOne = dlmlen - 1_IK

        ibeg = 0_IK
        ipart = 1_IK
        PartBegin(ipart) = 1_IK
        loopParseString: do

            ibeg = ibeg + 1_IK
            iend = ibeg + dlmlenMinusOne

            if (strlen<iend) then ! the remaining part of the string is shorter than the delim
                PartEnd(ipart) = strlen
                exit loopParseString
            elseif ( string(ibeg:iend) == delim ) then
                PartEnd(ipart) = ibeg - 1_IK
                ipart = ipart + 1_IK
                PartBegin(ipart) = iend + 1_IK
                ibeg = iend
            end if

        end do loopParseString

        allocate(Parts(ipart))
        do i = 1, ipart
            Parts(i)%record = string(PartBegin(i):PartEnd(i))
        end do
        if (present(npart)) npart = ipart

        deallocate(PartBegin, PartEnd)

    end function split
    
end module String_mod

program eigmap

  call init

  call read_eigen
  call calc_dot

  call deallocate_all
  call credits

  write(*,'(a)') ' Execution terminated.'
  write(*,*)

  stop
end program eigmap
